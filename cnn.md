# CNN

### 流程

| 步骤 | 操作类型      | 参数                                         | 特征图尺寸变化  |
| ---- | ------------- | -------------------------------------------- | --------------- |
| 1    | 输入图像      | 无                                           | 224 × 224 × 3   |
| 2    | Conv1-1       | kernel=3×3, padding=1, stride=1, channels=64 | 224 × 224 × 64  |
| 3    | Conv1-2       | same                                         | 224 × 224 × 64  |
| 4    | MaxPool1      | kernel=2×2, stride=2                         | 112 × 112 × 64  |
| 5    | Conv2-1       | channels=128                                 | 112 × 112 × 128 |
| 6    | Conv2-2       | same                                         | 112 × 112 × 128 |
| 7    | MaxPool2      | kernel=2×2, stride=2                         | 56 × 56 × 128   |
| 8    | Conv3-1       | channels=256                                 | 56 × 56 × 256   |
| 9    | Conv3-2       | same                                         | 56 × 56 × 256   |
| 10   | Conv3-3       | same                                         | 56 × 56 × 256   |
| 11   | MaxPool3      | kernel=2×2, stride=2                         | 28 × 28 × 256   |
| 12   | Conv4-1       | channels=512                                 | 28 × 28 × 512   |
| 13   | Conv4-2       | same                                         | 28 × 28 × 512   |
| 14   | Conv4-3       | same                                         | 28 × 28 × 512   |
| 15   | MaxPool4      | kernel=2×2, stride=2                         | 14 × 14 × 512   |
| 16   | Conv5-1       | channels=512                                 | 14 × 14 × 512   |
| 17   | Conv5-2       | same                                         | 14 × 14 × 512   |
| 18   | Conv5-3       | same                                         | 14 × 14 × 512   |
| 19   | MaxPool5      | kernel=2×2, stride=2                         | 7 × 7 × 512     |
| 20   | Flatten       | 将空间维展平                                 | 1 × 25088       |
| 21   | FC1           | 4096个神经元                                 | 1 × 4096        |
| 22   | FC2           | 4096个神经元                                 | 1 × 4096        |
| 23   | FC3 / Softmax | 输出类别数（如1000）                         | 1 × 1000        |



### 卷积层操作

#### 输入：

- **图像尺寸：** 224×224×3，其中 3 是图像的通道数（RGB 彩色图像）。

#### 操作：卷积（Conv1-1）

- **卷积核尺寸（Kernel Size）：** 3×3
- **步长（Stride）：** 1
- **填充（Padding）：** 1
- **卷积核数量（Filters）：** 64（表示输出特征图的通道数）

#### 步骤：

1. **卷积核应用：** 我们用一个 3×3 大小的卷积核（filter）滑动图像，每次滑动一步（步长=1），计算卷积核和图像局部区域的加权和，生成新的特征图。每个卷积核会产生一个特征图通道（feature map）。

2. **填充：** 为了保持卷积前后的图像尺寸一致，我们在图像的四周添加了填充（padding）。对于大小为 3×3 的卷积核，padding=1 意味着在图像的边缘加 1 像素的零填充，这样就能确保输出特征图的空间尺寸（宽度和高度）不变。

   例如，若输入图像尺寸为 224×224，经过填充后，每个边界增加 1 像素，填充后的图像尺寸变为 226×226。

3. **卷积运算：** 使用 64 个 3×3 的卷积核，分别对每个局部区域进行卷积操作，生成 64 个不同的特征图。每个卷积核产生一个特征图（feature map）。

#### 输出：

- **特征图尺寸：** 经过卷积后，输出的特征图的空间尺寸依然是 224×224，因为填充（padding=1）保证了输出图像的尺寸不变。
- **通道数：** 卷积操作将图像的通道数从 3（RGB）扩展到 64（使用 64 个卷积核生成 64 个特征图）。
- **输出尺寸：** 224×224×64，即每个位置的 64 个特征图通道的值。



### 步骤（加权和计算）：

1. **每个通道单独相乘：**
   - 第一个通道的图像块（3×3×3）和卷积核的第一个通道（3×3×3）逐元素相乘；
   - 第二个通道同理；
   - 第三个通道同理。
2. **三个通道分别的乘积求和（每个通道一个值）：**
   - 得到三个标量（每个通道的加权和）
3. **三个标量再相加：**
   - 得到最终的卷积结果（一个值）

##  EG

### 输入图像 patch（三个通道）：

- **R 通道（红）**：

```
nginxCopyEditr0 r1 r2
r3 r4 r5
r6 r7 r8
```

- **G 通道（绿）**：

```
nginxCopyEditg0 g1 g2
g3 g4 g5
g6 g7 g8
```

- **B 通道（蓝）**：

```
nginxCopyEditb0 b1 b2
b3 b4 b5
b6 b7 b8
```

------

## 🧰 卷积核（三个通道）：

你给出了 3 个部分，对应每个通道一个卷积核：

- **R 通道核：** a0∼a8a_0 \sim a_8a0∼a8
- **G 通道核：** b0∼b8b_0 \sim b_8b0∼b8
- **B 通道核：** c0∼c8c_0 \sim c_8c0∼c8

------

## ✅ 现在计算输出值（单个像素）

卷积操作是对每个通道分别做点乘，然后加总：

output=(∑i=08ri⋅ai)+(∑i=08gi⋅bi)+(∑i=08bi⋅ci)\text{output} = \left( \sum_{i=0}^{8} r_i \cdot a_i \right) + \left( \sum_{i=0}^{8} g_i \cdot b_i \right) + \left( \sum_{i=0}^{8} b_i \cdot c_i \right)output=(i=0∑8ri⋅ai)+(i=0∑8gi⋅bi)+(i=0∑8bi⋅ci)

------

## 📌 最终表达式是：

$/ output=(r0a0+r1a1+…+r8a8)+(g0b0+g1b1+…+g8b8)+(b0c0+b1c1+…+b8c8)\text{output} = (r_0 a_0 + r_1 a_1 + \ldots + r_8 a_8) + (g_0 b_0 + g_1 b_1 + \ldots + g_8 b_8) + (b_0 c_0 + b_1 c_1 + \ldots + b_8 c_8)output=(r0a0+r1a1+…+r8a8)+(g0b0+g1b1+…+g8b8)+(b0c0+b1c1+…+b8c8) /$



## MaxPooling

**MaxPooling** 是一种降维操作：
 👉 在每个局部区域内，取出**最大值**作为代表，缩小特征图的空间尺寸，同时保留最显著的特征。

------

## 🔧 典型参数设置

- **kernel size（窗口大小）：** 通常为 `2×2` 或 `3×3`
- **stride（步长）：** 通常与 kernel 一样（例如 stride=2）
- **padding：** 是否需要在边缘补0，通常为 0

------

## 🧮 举个具体例子

### 输入特征图（单通道）：

一个 4×4 的小矩阵：

```
1  3  2  4  
5  6  1  2  
7  2  9  8  
4  3  6  5  
```

### 操作：MaxPool with kernel=2×2, stride=2

我们将每个 2×2 的区域取最大值：

| 滑动窗口位置 | 2×2区块值 | 最大值 |
| ------------ | --------- | ------ |
| 左上         | 1 3 5 6   | 6      |
| 右上         | 2 4 1 2   | 4      |
| 左下         | 7 2 4 3   | 7      |
| 右下         | 9 8 6 5   | 9      |



### 结果输出（2×2）：

```
6 4  
7 9
```
